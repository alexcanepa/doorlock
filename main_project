#include <Keypad.h>
#include <Key.h>


//following lines from AdaFruit's example h  
//this sets up the keypad
const byte ROWS = 4; //four rows
const byte COLS = 3; //three columns
char keys[ROWS][COLS] = {
  {'1','2','3'},
  {'4','5','6'},
  {'7','8','9'},
  {'*','0','#'}
};
byte rowPins[ROWS] = {23, 22, 21, 20}; //connect to the row pinouts of the keypad
byte colPins[COLS] = {16, 15, 14}; //connect to the column pinouts of the keypad

Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS );
//this ends the sample code


String passcode = "1234";
int SolenoidPin = 9;
int LedPin = 13;
int failed_attempts = 0;
int allowed_fails = 3;

void take_picture(){
  //TODO, need Alex
  }

void passcode_fail(){
  /*
  This is a wrapper function to handle when we fail a passcode.
  We hope to prevent repetition of code.
  */
  failed_attempts ++;
  if(failed_attempts > allowed_fails){
    take_picture();
    failed_attempts = 0;
    } 
  }

String enter_code(){
  /* 
  This is a helper function which loops in order to add digits to a string
  Exits on 
  */
  char key = keypad.getKey();
  String char_string = "";
  while(key != '*'){
    if(key != 0){
      if(key == '#'){
        return "";}
      else{
        char_string.append(String(key));
        Serial.println(key);
      }}
    delay(100);
    key = keypad.getKey();
    }
  return char_string;
  }

boolean attempting_state(String code = passcode){
  /*
  This function is triggered when we determine that the user is attemping to enter a password
  It then loops until it finds the star key, and then decides if the password being entered matches the saved passcode
  If it does, return true, else false.
  */
  String attempt = enter_code();
  if(attempt != code and attempt != ""){
    passcode_fail();
    //wrapper because anytime we attempt the password, either to change it or open the lock, we want the same failure mode, not true for passing
    //note that if we exit with an empty string we don't want that to count as an attempt.
    }
  return (attempt == code);
  }

boolean update_state(){
  /*
  This is a function which handles the updating of the passcode.
  */
  Serial.println("Please enter your current passcode.");
  boolean correct_passcode = attempting_state(); //calls the default with the passcode
  if (correct_passcode){
    Serial.println("Enter your new passcode. End with * key.");
    String new_passcode = enter_code();
    if(new_passcode == "" or new_passcode.length() > 16){
      Serial.println("Passcodes must contain between 1 and 16 characters.");
      return false;}
    Serial.println("Please enter the password again. End with * key.");
    boolean can_update = attempting_state(new_passcode);
    if(can_update){
      passcode = new_passcode;
      return true;
      }
    else{
      Serial.println("Codes do not match");
      return false;}
    }
  else{
    Serial.println("Passcode failed");
    return false;
    }
  
  
  }

void setup() {
  pinMode(SolenoidPin, OUTPUT);
  pinMode(LedPin, OUTPUT);
}

void loop() {
  char key = keypad.getKey();
  if(key == '#')
    {
    boolean updated = update_state(); 
    if(updated){
      Serial.println("Passcode updated");
      }
    else{
      Serial.println("Passcode update failed");
      }
    }
  else if (key == '*')
    {
    Serial.println("Attempting unlock");
    boolean unlocked = attempting_state();
    if (unlocked)
      {
      failed_attempts = 0;
      for (int i = 0; i < 30; i++)
      {
         // Flash the led to indicate the lock is open
         digitalWrite(SolenoidPin, HIGH);
         digitalWrite(LedPin, LOW);
         delay(50);
         digitalWrite(LedPin, HIGH);
         delay(50);
      }
      digitalWrite(SolenoidPin, LOW);
      }
    }
    delay(100);
  }
